# 5장. CPU 성능 향상 기법

## 5-1. 빠른 CPU를 위한 설계 기법

### 클럭

- 클럭 속도
  - 속도가 높아지면, CPU 는 명령어 사이클을 더 빠르게 반복할 것이고 다른 부품들도 이에 맞춰 더 빠르게 작동할 것이다.
    - 실제로 클럭 속도가 높은 CPU 는 일반적으로 성능이 좋다.
  - 클럭 속도는 헤르츠(Hz) 단위로 측정한다.
    - 예를 들어, CPU 클럭 속도가 4.9GHz(MAX), 2.5GHz(BASE) 라는 것은 1초에 클럭이 25~49억 번 반복된다는 것을 나타낸다.
    - 고성능을 요하는 순간에 순간적으로 클럭 속도를 높일 수 있는데, 이를 overclocking 이라고 한다.
  - 클럭 속도를 무작정 높인다고 CPU 가 빨라지지 않는다.
    - 발열 문제가 이에 영향을 줄 수 있고, 클럭 속도 만으로 성능을 올리는 것은 한계가 있다.

### 코어와 멀티코어

- 코어는 "명령어를 실행하는 부품을 여러 개 포함하는 부품" 이다.
  - 예전엔 명령어를 실행하는 부품이 하나만 존재했으나, 기술의 발달로 이를 여러 개 포함할 수 있게 되었다.
  - 가령, 2.4GHz 단일 코어 CPU 보다 1.9GHz 인 멀티 코어 CPU 의 성능이 더 좋다.
- CPU 의 연산 속도가 코어 수에 비례하여 증가하진 않는다.
  - 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지는 않는다.
- 중요한 것은 **코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐** 이다.

### 쓰레드와 멀티스레드

**쓰레드란 무엇인가...**

- 사전적인 정의

  - 실행 흐름의 단위.
  - 그러나 용례에 따라 쓰레드가 사용되는 의미는 다르게 받아들여질 수 있다.
    따라서, 우리는 하드웨어 / 소프트웨어 적 쓰레드로 구분을 하자.

- **하드웨어적 스레드**
  - 하드웨어적인 정의는 "**하나의 코어가 동시에 처리하는 명령어** 단위" 이다.
    - 보통 CPU 입장에서 정의된 쓰레드를 의미한다.
  - **멀티스레드 프로세서**
    - 여러 쓰레드를 지원하는 CPU 는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다.
    - 이를 위해선, 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터들을 여러 개 가지고 있어야 한다.
  - **논리 프로세서**
    - 메모리 속 프로그램 입장에선 실행 가능한 쓰레드가 몇 개 이던, 한 번에 여러 개의 코어를 가지고 있는 것으로 보인다.
    - 가령, 2코어 4쓰레드 CPU 는 한 번에 4개의 명령어를 실행할 수 있는데,
      프로그램 입장에선 4개의 CPU 를 가지고 있는 것으로 보인다.
    - 이 때문에 하드웨어 쓰레드를 **논리 프로세서**라고 부르기도 한다.
- **소프트웨어적 스레드**
  - 소프트웨어적인 정의는, **"하나의 프로그램에서 독립적으로 실행하는 단위"** 를 의미한다.
    - 가령, 하나의 프로그램은 실행 과정에서 여러 부분이 동시에 실행될 수 있다.

## 5-2. 명령어 병렬 처리 기법

> _빠른 CPU 를 만드려면 높은 클럭 속도, 멀티코어, 멀티쓰레드를 지원하는 CPU 를 만드는게 중요하다._ > _그러나, CPU 가 놀지 않고 알뜰하게 시간을 쓰며 작동하게 만드는 것도 중요하다._
>
> _즉, **명령어 병렬 처리 기법**이 중요하다._

### 명령어 파이프라인

- 명령어 파이프라이닝
  - 명령어들을 **명령어 파이느라인 (instruction pipeline)** 에 넣고 동시에 처리하는 기법.
- **Pipeline Hazard**
  - 데이터 위험
    - 어떤 명령어는 특정 명령어를 끝까지 실행해야 비로서 실행할 수 있다.
      이와 같은 **명령어 간 "데이터 의존성"**에 의해 발생한다.
  - 제어 위험
    - 분기 등으로 인한 **"프로그램 카운터의 갑작스러운 변화"** 에 의해 발생한다.
      이를 위해 프로그램이 어디로 분기할 지 미리 예측할 후 그 주소를 인출하는 기술이 있는데,
      이를 **분기 예측(branch prediction)** 이라고 한다.
  - 구조적 위험
    - 서로 다른 명령어가 동시에 ALU, 레지스터와 같은 CPU 부품을 사용하려 할 때 발생한다.
      **자원 위험(resource hazard)** 이라고도 부른다.

### 슈퍼스칼라

- 슈퍼스칼라
  - CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **superscaler** 라고 한다.
- 슈퍼스칼라 프로세서 / CPU
  - 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU.
  - 매 클럭 주기마다 동시에 여러 명령어 인출, 실행이 가능해야 한다.
    - 멀티쓰레드 프로세서는 한번에 여러 명령어를 인출, 해석, 실행할 수 있으므로 슈퍼스칼라 구조를 사용할 수 있다.
  - 이론적으론 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라져야 하지만,
    Pipeline Hazard 등의 문제로 반드시 개수에 비례해 속도가 증가하진 않는다.

### 비순차적 명령어 처리

- **OoOE(Out-of-order execution)**
  - 파이프라인 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 병렬 처리 기법.
  - OoOE 가 간으한 CPU 는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있고,
    순서를 바꿔 실행할 수 있는 명령어는 어떤 것들이 있는지 알 수 있어야 한다.

## 5-3. CISC과 RISC

> _명령어 파이프라이닝, 슈퍼스칼라 기법을 적용하기 위해선 명령어가 파이프라이닝에 최적화되어 있어야 한다._
>
> _이번 장에선 **파이프라이닝에 유리한 명령어를 위한 설계**에 대해 알아본다._

### 명령어 집합

- ISA (Instruction Set Architecture)
  - CPU 가 이해할 수 있는 명령어 모음.
    - 가령, x86 을 사용하는 인텔 노트북 CPU 와 ARM ISA 를 사용하는 아이폰 CPU 는 다른 ISA 이기 때문에,
      각자의 실행 파일을 실행할 수 없다.
  - ISA 가 달라짐에 따라 제어장치의 명령어 해석 방식, 사용하는 레지스터 종류, 개수, 메모리 관리 방법 등이 모두 달라진다.

### CISC

- CISC (Complex Instruction Set Computer)

  - CISC 는 **가변 길이 명령어**를 사용한다.
    - 명령어의 형태와 크기가 다양하며 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
    - 이런 점은 메모리를 최대한 아끼며 개발해야 했던 시기에 인기가 높았다.

- 한계

  - CISC 는 **명령어의 크기와 실행되기 까지의 시간이 일정하지 않다.**

    - 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만들었다.

    - 이는 명령어 파이프라인을 구현하는 데에 큰 걸림돌이 된다.

  - 대다수의 복잡한 명령어의 사용 빈도가 낮다.

    - 복잡한 기능을 지원하는 명령어 추가보단 자주 쓰이는 기본 명령어를 작고 빠르게 만들어야 한다.

### RISC

- RISC(Reduced Instruction Sec Computer)
  - RISC 는 **고정 길이 명령어**를 활용한다.
    - 명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행된다.
    - 따라서 명령어 파이프라이닝에 최적화되어 있다.
  - RISC 는 메모리 접근을 단순화하고 최소화를 추구한다.
    - 가령, 메모리 직접 접근 명령어가 load, store 두 개로 제한되어 있다.
    - 이 때문에 CISC 보다 주소 지정 방식의 종류가 적은 경우가 만핟.
  - RISC 는 레지스터를 적극적으로 활용한다.
    - CISC 에 비해 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 많다.
